<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Tr0e"><meta name="copyright" content="Tr0e"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>IDA动态调试破解AliCrackme与反调试对抗 | Cyber Security</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"tr0e.github.io","root":"/","title":["Tr0e","Blog"],"version":"1.10.4","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="Cyber Security" type="application/atom+xml"><meta name="description" content="前言在前面的文章中 IDA动态调试破解EXE文件与分析APK流程 介绍了 IDA 对 APK 进行动态调试分析的简单流程，然而实际上很多 APP 为了防止被动态调试分析，经常会做一些反调试的防护措施。本文将通过 2014 年阿里安全挑战赛的第二题 AliCrackme_2（APK下载地址），来进一步学习 APK so 文件的动态调试和反调试技术的对抗。 APK破解(上)显然，上面的程序希望我们输入">
<meta property="og:type" content="article">
<meta property="og:title" content="IDA动态调试破解AliCrackme与反调试对抗">
<meta property="og:url" content="https://tr0e.github.io/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A0%B4%E8%A7%A3AliCrackme%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E5%AF%B9%E6%8A%97/index.html">
<meta property="og:site_name" content="Cyber Security">
<meta property="og:description" content="前言在前面的文章中 IDA动态调试破解EXE文件与分析APK流程 介绍了 IDA 对 APK 进行动态调试分析的简单流程，然而实际上很多 APP 为了防止被动态调试分析，经常会做一些反调试的防护措施。本文将通过 2014 年阿里安全挑战赛的第二题 AliCrackme_2（APK下载地址），来进一步学习 APK so 文件的动态调试和反调试技术的对抗。 APK破解(上)显然，上面的程序希望我们输入">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6bc29cfe66ff4087ac3a97b960f8c380.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/385e10a961fd46b89876bb5010da5569.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/01b855bde6e544e7b50a6d656f62ab0e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/9f5bc72ec21f468c9e229987390a8b79.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/4a97e5499e0a434e9551fb8a7a8fdc51.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/3055d756670f4f8b8ae7dcc7ecef8871.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4c4f5dc2d7a34c40a3f6697dfc0c992e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/becfbdfafdcb4d6dbf4002f3ce7166d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/3cbab0687f7743c9be4985ac51076eca.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6357d3dcb962408eaa6b4fac76e6607b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/dd59b295951c4d519454166b6c6cc141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/e1cf64f869fc4debb446c926ebfa9058.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/bbc793c98e8d4df88c62572bbf17d65e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d6181e62ec4d4de1865e24eab40aa674.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/49b4457b2a5849c5b78f43ae9a78bce2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6c70393ce43547438113b834d10a5803.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5cc3d3815ff24625a290c31ad1c4e534.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/23828bc56616434fa5f3cb1809664e4a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/355c7a9f9cfd4b69a57889536aed8e15.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e8c56dbb11b246eab8207fb3a89bb4e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b0aeaaf003104cd4992a2e6e85b40ead.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/ddbbcd62d51a444da66b011ad52f3d8b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6f7f02a6088a410aa0fb471605728301.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/3e7609f6da1a4c82841bbf396bb529e5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b0aeaaf003104cd4992a2e6e85b40ead.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/487a7b21b3c04bc8848ab214ef513430.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/82e6666ea2464b53804a014798ca1a17.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/258dcb37d5f34e71ae075cda30707969.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/a495c8539dc643d48af349202fb74e07.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/78e08ab9a338452abc07b311faf02b37.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/08189027a9c847dc8a733cd28b118421.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6ac3bcc40ea64612b030924436471a56.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/fa858e7db20f411ea76bf3c708aa121f.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/e217fa6cc8d24966b1daaa3fe9732050.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/272d890318cc4b409edae79f71b41f20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3e25c06e0c6b458e9dc51e47f5e62df1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/51c0e30db6894132bae827c359f0f4f1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/14dd259cf527452e80ce7b6b3a6822e4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7ba94685d9924c618679d5c276205c50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b9cf9962a3c449fd96f9900280a948f0.png">
<meta property="article:published_time" content="2021-10-17T08:16:33.000Z">
<meta property="article:modified_time" content="2022-06-15T16:05:37.652Z">
<meta property="article:author" content="Tr0e">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6bc29cfe66ff4087ac3a97b960f8c380.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Tr0e"><img width="96" loading="lazy" src="/images/Tr0e.jpg" alt="Tr0e"></a><div class="site-author-name"><a href="/about/">Tr0e</a></div><span class="site-name">Cyber Security</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/about/" title="About Me" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APK%E7%A0%B4%E8%A7%A3-%E4%B8%8A"><span class="toc-number">2.</span> <span class="toc-text">APK破解(上)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 静态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 动态分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E5%AF%B9%E6%8A%97"><span class="toc-number">3.</span> <span class="toc-text">反调试对抗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Ptrace"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 Ptrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%85%A8%E5%B1%80%E8%B0%83%E8%AF%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 全局调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 反反调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APK%E7%A0%B4%E8%A7%A3-%E4%B8%8B"><span class="toc-number">4.</span> <span class="toc-text">APK破解(下)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 重新编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 动态调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://tr0e.github.io/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A0%B4%E8%A7%A3AliCrackme%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E5%AF%B9%E6%8A%97/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Tr0e"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Cyber Security"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">IDA动态调试破解AliCrackme与反调试对抗</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2021-10-17 16:16:33" itemprop="dateCreated datePublished" datetime="2021-10-17T16:16:33+08:00">2021-10-17</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">终端安全</span></a></span></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的文章中 <a target="_blank" rel="noopener" href="https://bwshen.blog.csdn.net/article/details/120699662">IDA动态调试破解EXE文件与分析APK流程</a> 介绍了 IDA 对 APK 进行动态调试分析的简单流程，然而实际上很多 APP 为了防止被动态调试分析，经常会做一些反调试的防护措施。本文将通过 2014 年阿里安全挑战赛的第二题 AliCrackme_2（<a target="_blank" rel="noopener" href="https://yirj.lanzoui.com/iehe4ity92h">APK下载地址</a>），来进一步学习 APK so 文件的动态调试和反调试技术的对抗。<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6bc29cfe66ff4087ac3a97b960f8c380.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="APK破解-上"><a href="#APK破解-上" class="headerlink" title="APK破解(上)"></a>APK破解(上)</h1><p>显然，上面的程序希望我们输入正确的验证码/密码，故破解的目标就是获取到正确的密码（即 Flag 值）。</p>
<h2 id="1-1-静态分析"><a href="#1-1-静态分析" class="headerlink" title="1.1 静态分析"></a>1.1 静态分析</h2><p>1、先拖进 jadx 查看其验证码校验逻辑，发现程序调用了 libcrackme.so 的 securityCheck() 函数对输入密码进行校验，如果正确则启动一个新的活动，否则则提示验证码校验错误：<br><img src="https://img-blog.csdnimg.cn/385e10a961fd46b89876bb5010da5569.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">2、将 libcrackme.so 文件导出并拖进 IDA 进行静态分析：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/01b855bde6e544e7b50a6d656f62ab0e.png" alt="在这里插入图片描述" loading="lazy">3、按 F5 转换成伪代码：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/9f5bc72ec21f468c9e229987390a8b79.png" alt="在这里插入图片描述" loading="lazy">发觉 v6 变量 off_628C 可能有东西，双击跟进看看：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/4a97e5499e0a434e9551fb8a7a8fdc51.png" alt="在这里插入图片描述" loading="lazy"><br>4、进行 JNI 函数方法名还原，可以较清晰地分析出程序的逻辑：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/3055d756670f4f8b8ae7dcc7ecef8871.png" alt="在这里插入图片描述" loading="lazy">C 伪代码的解释我已添加在备注中，可以看出接下来的目标就是通过 IDA 动态调试来获取真实的 v6 变量（真实的密码）的值。</p>
<h2 id="1-2-动态分析"><a href="#1-2-动态分析" class="headerlink" title="1.2 动态分析"></a>1.2 动态分析</h2><p>1、在 securityCheck() 函数如下位置设置断点：<br><img src="https://img-blog.csdnimg.cn/4c4f5dc2d7a34c40a3f6697dfc0c992e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">2、在真机 Nexus5 中安装目标 APK，运行 IDA 调试服务并转发端口：<br><img src="https://img-blog.csdnimg.cn/becfbdfafdcb4d6dbf4002f3ce7166d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">3、设置 IDA Debugger：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/3cbab0687f7743c9be4985ac51076eca.png" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/6357d3dcb962408eaa6b4fac76e6607b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>4、启动 APP 并在 IDA 进行进程附加：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/dd59b295951c4d519454166b6c6cc141.png" alt="在这里插入图片描述" loading="lazy"><br>5、然而发现附加进程后，一点击运行程序按钮（或者 F9 快捷键），程序立马闪退……<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/e1cf64f869fc4debb446c926ebfa9058.png" alt="在这里插入图片描述" loading="lazy">可以猜测该 APP 使用了反调试机制防止程序被动态调试分析，想进一步调试分析，必须绕过其反调试机制。</p>
<h1 id="反调试对抗"><a href="#反调试对抗" class="headerlink" title="反调试对抗"></a>反调试对抗</h1><p>接下来来通过 IDA 动态调试分析 APP 的反调试检测机制，并进行对抗和破解，使得目标 APP 能够被我们正常地调试。</p>
<h2 id="2-1-Ptrace"><a href="#2-1-Ptrace" class="headerlink" title="2.1 Ptrace"></a>2.1 Ptrace</h2><blockquote>
<p>【反调试原理】IDA 是使用 android_server 在 root 环境下注入到被调试的 APP 程序进程中，那么对抗调试就可以利用 Linux 系统的 ptrace 来实现，当 Android 应用被调试时应用内存里的 TracerPid 字段就不为 0（即在其 status 文件中有一个字段 TracerPid 可以标识是被哪一个进程 trace 了)，只要是不为 0 的时候，就会直接的退出程序，达到反调试的目的。</p>
</blockquote>
<p>来验证一下上述调试过程中，真机上目标 APP 进程的 ptrace 字段：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">进入设备：adb shell
获取Root权限：su
获得APP的进程ID：ps <span class="token operator">|</span> <span class="token function">grep</span> 软件的包名
查看进程的信息及TracerPid值： <span class="token function">cat</span> /proc/进程ID/status</code></pre>
<p>结果如下，可以看到程序进程被进程 id 为 16453 的进程所附加：<br><img src="https://img-blog.csdnimg.cn/bbc793c98e8d4df88c62572bbf17d65e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">Linux 系统中 ptrace 系统调用提供了一个进程 (tracer) 可以控制另一个进程 (tracee) 运行的方法，并且 tracer 可以监控和修改 tracee 的内存和寄存器，主要用作实现断点调试和系统调用追踪。具体可参见看雪的文章：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-265812.htm">[原创] Linux ptrace详细分析系列（一）</a>，此处不展开介绍。</p>
<h2 id="2-2-全局调试"><a href="#2-2-全局调试" class="headerlink" title="2.2 全局调试"></a>2.2 全局调试</h2><p>既然目标 APP 在 so 文件进行了反调试，那么要想破解反调试机制，就需要对 so 文件进行调试（静态分析你要是能分析出来也行……）。但是前面的调试过程已经以失败告终，无法正常运行程序，那该怎么办？</p>
<p>进行常规 IDA 调试过程，只要一运行目标 APP 程序就会强制退出了调试界面，说明目标 APP 循环检测被调试状态的函数执行的时机非常早。幸运的是，有两个地方是 so 动态加载完毕前执行的：</p>
<ol>
<li><code>.init_array</code> 是一个so最先加载的一个段信息，时机最早，现在一般 so 解密操作都是在这里做的；</li>
<li><code>JNI_OnLoad</code> 是 so 被 System.loadLibrary 调用的时候执行的，它的时机早于 native 方法的执行。</li>
</ol>
<p>那么知道了这两个时机，下面我们先来看看是不是在<code>JNI_OnLoad</code>函数中做的策略，所以我们需要先动态调试<code>JNI_OnLoad</code>函数。我们既然知道了 JNI_OnLoad 函数的时机，如果阿里把检测函数放在这里的话，我们不能用之前的方式去调试了，因为之前的那种方式时机太晚了，只要运行就已经执行了 JNI_OnLoad 函数，所以就会退出调试页面。</p>
<p>1、接下来我们就尝试断在 JNI_OnLoad 函数指令处，先在  JNI_OnLoad 函数设置断点并在 debugger 设置中勾选如下选项：<br><img src="https://img-blog.csdnimg.cn/d6181e62ec4d4de1865e24eab40aa674.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">2、但是由于被调试程序一运行就会执行 static 中的语句，因此需要让程序停在加载 so 文件之前，这里可以添加 watiForDebugger，或者使用更加简单的方法，使用 debug 方式来启动 APP： </p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">adb shell am start <span class="token operator">-</span><span class="token constant">D</span> <span class="token operator">-</span>n com<span class="token punctuation">.</span>yaotong<span class="token punctuation">.</span>crackme<span class="token operator">/</span><span class="token punctuation">.</span>MainActivity </code></pre>
<p>运行该命令后，目标 APP 将处于一个等待 Debugger 的状态：<br><img src="https://img-blog.csdnimg.cn/49b4457b2a5849c5b78f43ae9a78bce2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>3、IDA 开始对进程进行附加：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6c70393ce43547438113b834d10a5803.png" alt="在这里插入图片描述" loading="lazy"><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5cc3d3815ff24625a290c31ad1c4e534.png" alt="在这里插入图片描述" loading="lazy"><br>4、接着执行如下命令让 APP 运行起来：</p>
<pre class="language-c" data-language="c"><code class="language-c">进入设备： adb shell
获取Root权限：su
获得APP的进程ID：ps <span class="token operator">|</span> grep com<span class="token punctuation">.</span>yaotong<span class="token punctuation">.</span>crackme （直接关注上一步进程附加的 ID 也可以获得）
监听进程的ID：adb forward tcp<span class="token operator">:</span><span class="token number">8700</span> jdwp<span class="token operator">:</span><span class="token number">4495</span>（<span class="token number">4495</span>为上面获得的APP进程ID）
运行进程：jdb <span class="token operator">-</span>connect com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>jdi<span class="token punctuation">.</span>SocketAttach<span class="token operator">:</span>hostname<span class="token operator">=</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">,</span>port<span class="token operator">=</span><span class="token number">8700</span></code></pre>
<p>执行过程如下：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/23828bc56616434fa5f3cb1809664e4a.png" alt="在这里插入图片描述" loading="lazy">5、返回 IDA 按 F9 开始运行程序：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/355c7a9f9cfd4b69a57889536aed8e15.png" alt="在这里插入图片描述" loading="lazy">此时 APP 由等待 Debugger 状态进入如下页面：<br><img src="https://img-blog.csdnimg.cn/e8c56dbb11b246eab8207fb3a89bb4e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>6、继续按一下运行程序的按钮（或者 F9 快捷键），程序即会运行到刚才我设置的 JNI_OnLoad 函数断点处：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b0aeaaf003104cd4992a2e6e85b40ead.png" alt="在这里插入图片描述" loading="lazy">【注意】程序没有直接闪退的原因是此处的断点位置在检测调试的代码前面，故我们接下来就可以往下逐步运行程序来调试分析反调试的代码的逻辑和位置！</p>
<p>7、在进一步进行调试分析反调试检测代码前，我想补充一个点，实际上上面加载  JNI_OnLoad 函数断点的调试过程我在首次执行时失败，执行<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code>命令时遇到如下报错：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/ddbbcd62d51a444da66b011ad52f3d8b.png" alt="在这里插入图片描述" loading="lazy">报错的原因是目标 APP 不可被调试！解决的办法是修改 APP  AndroidMenifest.xml 文件， 在 &lt;application 里给APP加上可调试权限，<code>android:debuggable=&quot;true&quot;</code>，重新打包 APP 后重现编译、签名、安装，如下图所示：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6f7f02a6088a410aa0fb471605728301.png" alt="在这里插入图片描述" loading="lazy">8、可见在 Android 真机上调试程序有一个前提，就是这个 apk 包必须有 <code>debuggable=true</code> 的属性才行，而除了自己开发的 apk 能够控制打包属性之外，其他的程序发行之后显然不会设这个值为 true 的（打包 APK 时 release 发布版本默认为 false 不可调试，只有 debug 版本可调试）。为了调试 APK 而每次都去修改配置文件并重打包也太麻烦了，实际上为了调试这些第三方的 apk，我们可以从整个手机系统入手 —— 因为除了每个 apk 中的 debuggable 标志以外，这个标志还可以在系统中全局指定，换句话说，只要把系统里的 debuggable 值设为 true（即将<code>/default.prop</code>中默认字段是 0 的<code>ro.debuggable</code>的值修改为 1，前提是手机需要 root ），那么不管 apk 的这个属性是什么值，该手机上的 APP 都可以被调试了。修改 ro.debuggable 的步骤：</p>
<pre class="language-c" data-language="c"><code class="language-c">下载 mprop 工具：https<span class="token operator">:</span><span class="token comment">//github.com/wpvsyou/mprop</span>
adb push mprop <span class="token operator">/</span>data<span class="token operator">/</span>local<span class="token operator">/</span>tmp # 将下载的mprop 放入 <span class="token operator">/</span>data<span class="token operator">/</span>local<span class="token operator">/</span>tmp 当中
adb shell
su
cat <span class="token keyword">default</span><span class="token punctuation">.</span>prop <span class="token operator">|</span> grep debug # 查看<span class="token keyword">default</span><span class="token punctuation">.</span>prop里面的配置值，此处是 <span class="token number">0</span>
getprop ro<span class="token punctuation">.</span>debuggable         # 获取ro<span class="token punctuation">.</span>debuggable 此处应该是 <span class="token number">0</span>
cd <span class="token operator">/</span>data<span class="token operator">/</span>local<span class="token operator">/</span>tmp
chmod <span class="token number">755</span> mprop               # 修改权限
<span class="token punctuation">.</span><span class="token operator">/</span>mprop ro<span class="token punctuation">.</span>debuggable <span class="token number">1</span>       # 修改 ro<span class="token punctuation">.</span>debuggable <span class="token number">1</span> 的值为 <span class="token number">1</span>
cat <span class="token keyword">default</span><span class="token punctuation">.</span>prop <span class="token operator">|</span> grep debug # 查看<span class="token keyword">default</span><span class="token punctuation">.</span>prop里面的配置值，此处是应该还是 <span class="token number">0</span>
getprop ro<span class="token punctuation">.</span>debuggable         # 获取 ro<span class="token punctuation">.</span>debuggable 此处应该是 <span class="token number">1</span></code></pre>
<p>ok，修改完成后，再次看下是不是可以调试了，执行命令<code>adb shell getprop | findstr debuggable</code>查看手机的<code>ro.debuggable</code>参数值：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/3e7609f6da1a4c82841bbf396bb529e5.png" alt="在这里插入图片描述" loading="lazy"><br>【<strong>再次强调</strong>】上面修改<code>ro.debuggable</code>参数值的过程需要在已 root 的手机中进行，同时手机再次重启后需要再次进行一次修改操作。</p>
<h2 id="2-3-反反调试"><a href="#2-3-反反调试" class="headerlink" title="2.3 反反调试"></a>2.3 反反调试</h2><p>好了，介绍完将真机设置全局可调试的模式后，我们返回到  JNI_OnLoad 函数断点处，继续分析程序检测调试状态的代码逻辑。<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b0aeaaf003104cd4992a2e6e85b40ead.png" alt="在这里插入图片描述" loading="lazy"><br>此处先小结一下上述在  JNI_OnLoad 函数设置断点并拦截程序的过程（即 IDA 调试具有反调试机制的程序的步骤）：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token number">1</span>）启动 android_server
<span class="token number">2</span>）端口转发adb forward tcp<span class="token operator">:</span><span class="token number">23946</span> tcp<span class="token operator">:</span><span class="token number">23946</span>；
<span class="token number">3</span>）打开 IDA，设置 JNI_OnLoad 函数断点并在 debug options 中设置 load so 的时机；
<span class="token number">4</span>）adb shell am start <span class="token operator">-</span>D <span class="token operator">-</span>n 包名<span class="token operator">/</span>类名；出现 Debugger 的等待状态；
（说明：以启动模式启动，是停在加载so文件之前，包名可以在 Androidmanifest 文件中找到）
<span class="token number">5</span>）IDA Debugger 附加上对应的进程（留意目标 APP 的进程 ID）；
<span class="token number">6</span>）运行命令：
  adb forward tcp<span class="token operator">:</span><span class="token number">8700</span> jdwp<span class="token operator">:</span><span class="token number">4495</span>（<span class="token number">4495</span>为上面 IDA 附加的目标APP进程ID）
  jdb <span class="token operator">-</span>connect com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>jdi<span class="token punctuation">.</span>SocketAttach<span class="token operator">:</span>hostname<span class="token operator">=</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">,</span>port<span class="token operator">=</span><span class="token number">8700</span>
<span class="token number">7</span>）点击 IDA 运行按钮，或者F9快捷键。</code></pre>
<p>1、按 F8 单步步过，继续往下运行程序，但是当我们每次到达 <code>BLX R7</code>这条指令执行完之后，JNI_OnLoad 就退出了:<br><img src="https://img-blog.csdnimg.cn/487a7b21b3c04bc8848ab214ef513430.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/82e6666ea2464b53804a014798ca1a17.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>2、再次进入调试，看见运行到 BLX 跳转指令时 R7 寄存器中是 <code>pthread_create</code> 函数，这个是 Linux 中新建一个线程的方法：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/258dcb37d5f34e71ae075cda30707969.png" alt="在这里插入图片描述" loading="lazy">所以猜测阿里的反调试就在这里开启一个线程进行轮训操作，去读取<code>/proc/[pid]/status</code>文件中的 TrackerPid 字段值，如果发现不为 0，就表示有人在调试本应用，在 JNI_OnLoad 中直接退出。其实这里可以再详细进入查看具体代码实现的，但是这里限于篇幅问题，不详细解释了，后续将单独写一篇文章学习反调试机制，本文的重点是能够动态调试即可。</p>
<p>3、定位到关键的反调试检测代码位置后，该怎么绕过反调试检测？其实很简单，我们只要把<code>BLX R7</code>这段指令干掉即可，如果是 smali 代码的话，可以直接删除这行代码即可，但是 so 文件不一样，它是汇编指令，如果直接删除这条指令的话，文件会发生错乱，因为本身 so 文件就有固定的格式，比如很多 Segement 的内容，每个 Segement 的偏移值也是有保存的，如果这样去删除会影响这些偏移值，会破坏 so 文件格式，导致 so 加载出错的。所以这里我们不能手动的去删除这条指令，我们还有另外一种方法，就是把这条指令变成空指令，在汇编语言中，nop 指令就是一个空指令，它什么都不干，所以这里我们直接改一下指令即可，ARM 汇编中对应的 nop 指令是：<code>00 00 00 00</code>。首先恢复到静态分析的状态（退出动态分析），将鼠标定位到<code>BLX R7</code>指令处，切换到 “Hex View-1” 窗口可以看到该指令对应的十六进制表示形式为 <code>37 FF 2F E1</code>：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/a495c8539dc643d48af349202fb74e07.png" alt="在这里插入图片描述" loading="lazy"><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/78e08ab9a338452abc07b311faf02b37.png" alt="在这里插入图片描述" loading="lazy"><br>4、继续选中<code>BLX R7</code>指令然后选择如下“Change byte…”选项：<br><img src="https://img-blog.csdnimg.cn/08189027a9c847dc8a733cd28b118421.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">修改<code>37 FF 2F E1</code>为<code>00 00 00 00</code>：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6ac3bcc40ea64612b030924436471a56.png" alt="在这里插入图片描述" loading="lazy"><br>5、最后将所作的修改保存到 so 文件中（ IDA 中修改 SO 文件保存修改覆盖到 so 文件而非临时工程文件的方式：<code>edit-&gt;patch  program-&gt;  apply  patches  to  input  file...</code> ）：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/fa858e7db20f411ea76bf3c708aa121f.png" alt="在这里插入图片描述" loading="lazy">至此已完成自毁程序 so 文件的修改，使得反调试的检测核心逻辑代码被破坏，新的 so 文件中将无法正常调用反调试检测代码。</p>
<h1 id="APK破解-下"><a href="#APK破解-下" class="headerlink" title="APK破解(下)"></a>APK破解(下)</h1><p>完成上述工作，我们来将新的 so 文件替换掉原来自毁程序 APK 里面的 so 文件，并尝试对其正常的动态调试分析。</p>
<h2 id="3-1-重新编译"><a href="#3-1-重新编译" class="headerlink" title="3.1 重新编译"></a>3.1 重新编译</h2><p>1、将上面获得的新的 so 文件替换掉原来自毁程序 APK 里面的 so 文件：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/e217fa6cc8d24966b1daaa3fe9732050.png" alt="在这里插入图片描述" loading="lazy"><br>2、在 AndroidKiller 中重新编译、打包、重签名自毁程序 APK：<br><img src="https://img-blog.csdnimg.cn/272d890318cc4b409edae79f71b41f20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>接着将新的自毁程序 APK 一键安装到 Nexus5 测试机即可。</p>
<h2 id="3-2-动态调试"><a href="#3-2-动态调试" class="headerlink" title="3.2 动态调试"></a>3.2 动态调试</h2><p>新的自毁程序 APK 讲道理可以正常地被 IDA 动态调试分析而不会闪退了，下面来试试。</p>
<p>1、直接双击开始运行  APP 程序（无需再将 APP 处于一个等待 Debugger 的状态），然后正常运行 android_server 并转发 23946 端口，然后 debugger 勾选如下选项即可：<br><img src="https://img-blog.csdnimg.cn/3e25c06e0c6b458e9dc51e47f5e62df1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"><br>2、取消 JNI_OnLoad 函数的断点（该函数反调试的逻辑已被破坏，无需再拦截并调试该函数），直接在 securityCheck() 函数设置如下断点：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/51c0e30db6894132bae827c359f0f4f1.png" alt="在这里插入图片描述" loading="lazy">3、IDA 开始正常附加 APP 程序进程，点击运行按钮或 F9 继续运行程序，程序不再闪退！！！！往输入框输入 1234 字符串并提交，发现程序被成功拦截在刚才设置的断点处了：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/14dd259cf527452e80ce7b6b3a6822e4.png" alt="在这里插入图片描述" loading="lazy">4、切换到 IDA View-PC 窗口查看断点并 F8 单步步过运行程序，观察到 if 判断语句对应的汇编指令 R2 寄存器存放的字符串为 “aiyou,bucuoyoo”，也 就是我们想要的目标密码/flag：<br><img src="https://img-blog.csdnimg.cn/7ba94685d9924c618679d5c276205c50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVHIwZQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">5、将 flag 值输入自毁程序，成功破解密码：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b9cf9962a3c449fd96f9900280a948f0.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文篇幅相对较长，但也算学习了不少东西。从如何设置测试机真机全局可调试、再到 APK 反调试机制的动态分析和绕过、最后再到重编译程序并动态调试破解密码，整个实践流程下来耗费了不少时间（太菜了）……最后说一下，Android 反调试机制不局限于本例所提及的  TracerPid 字段检测，后面我将继续单独对 Android 反调试机制及其对抗机制进行学习。本文至此 Over！！！</p>
<p>本文参考文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-263810.htm">[原创]超级详细的实战分析一个Crackme的过程</a>（很细致，推荐）；</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbhgyu/article/details/81321923">安卓逆向实践5——IDA动态调试so源码</a>（分析很到位）；</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46204016/article/details/105605620">Android逆向之旅—动态方式破解apk进阶篇(IDA调试so源码)</a>（姜维大佬的文章）。</li>
</ol>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Tr0e</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://tr0e.github.io/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A0%B4%E8%A7%A3AliCrackme%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E5%AF%B9%E6%8A%97/" title="IDA动态调试破解AliCrackme与反调试对抗">https://tr0e.github.io/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A0%B4%E8%A7%A3AliCrackme%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E5%AF%B9%E6%8A%97/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/Android%E5%86%85%E6%A0%B8%E5%B1%82%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8FUAF%E6%BC%8F%E6%B4%9E%E6%8F%90%E6%9D%83%E5%AE%9E%E4%BE%8B/" rel="prev" title="Android内核层驱动程序UAF漏洞提权实例"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">Android内核层驱动程序UAF漏洞提权实例</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BShiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="next" title="JAVA代码审计之Shiro反序列化漏洞分析"><span class="post-nav-text">JAVA代码审计之Shiro反序列化漏洞分析</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Tr0e</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.2</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.4</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>