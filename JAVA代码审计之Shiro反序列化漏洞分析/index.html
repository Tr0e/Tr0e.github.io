<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Tr0e"><meta name="copyright" content="Tr0e"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>JAVA代码审计之Shiro反序列化漏洞分析 | Cyber Security</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"tr0e.github.io","root":"/","title":["Tr0e","Blog"],"version":"1.10.4","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="Cyber Security" type="application/atom+xml"><meta name="description" content="前言在前面的一篇文章：Apache Shiro Java反序列化漏洞复现 曾介绍了 CVE-2016-4437 漏洞的复现过程和利用方式，为了不再当个“脚本小子”工具人…本文将记录学习下从源码审计的角度分析 CVE-2016-4437 漏洞的原理。 Java反序列化同样的在前面一篇博文：Java-序列化与反序列化 已经讲述了 Java 序列化和反序列化的概念，此处简单再描述下。 把对象转换为字节序">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA代码审计之Shiro反序列化漏洞分析">
<meta property="og:url" content="https://tr0e.github.io/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BShiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Cyber Security">
<meta property="og:description" content="前言在前面的一篇文章：Apache Shiro Java反序列化漏洞复现 曾介绍了 CVE-2016-4437 漏洞的复现过程和利用方式，为了不再当个“脚本小子”工具人…本文将记录学习下从源码审计的角度分析 CVE-2016-4437 漏洞的原理。 Java反序列化同样的在前面一篇博文：Java-序列化与反序列化 已经讲述了 Java 序列化和反序列化的概念，此处简单再描述下。 把对象转换为字节序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/7864997cd6394c49993d994ea0b43ae9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ca674bfe48434e1c89d6f1e104675912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/f552f24c972241e190ad106a30e9c184.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/ee6b526e63584954b66d4b812c8fd643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b4c3ce063ade41d2816be118b27ae603.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d6649bdbd90e4ab68117bcee444c8ba6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/c80d0dee92f343598408ae429166095b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8089e47848bc4c99998997e9647c07f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/cf6e74b611ee4d9cb442d6cb580011d7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/eb7193051ac649e1a84754c95304456e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/cdee004cf6cc482eba35cf2029829ebb.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/f788bd07bf114fd08b52ea1da27eaefc.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/4b28af311e8e4422a486991775d6023a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/f79e66769e594faa87b260f0725df38b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c0f1974110a74d63bc812fce292f154d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/1f6bce5bdc5d4d7aaa92dfebf54830b4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/40edf49ee666483d97e9861c30622bef.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/49e7f80fd6ce484f95158dd51abaf9ec.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/8c8581e57bfc4cf4a3a590089e423dc2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/753d1bdd3c3644d4914a7b3969045cad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/73acb23c58e942b2a4174e836af67d72.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7b9609bc8adf4325a52de6451724f51a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5ec3cf0b782b4ba3a3b642278df1e5d8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/235318db40574f69b13b717c0b237349.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/9ee4baad44f2416da5451a6524e52e55.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4d14b8f6eb544b69a856d7bf5fa0bb23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/459933640c3549a080b7432e8521c9d5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/d13228bd3a264e1287453b0de327720b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c0f1974110a74d63bc812fce292f154d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c79e5406d7b048ebb5d9de0d510891c4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/98fbc3183ad44157988686ebaf712d1e.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/db03f21566644232a1e5420734c5e4d9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/31849a60ffb8441fac6c7199067c817a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9b205fc0ff9040a5a303c10108d05f22.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6bf234c7443b44018c5764741dfd18e1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/a010bff13b0b4b16ae6f17b8838f26f1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e0a5b4279a5340789275c33fdf779f2c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/66f00111e73442ad867148b25cb8557b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5681c04849a64475b429b126f9cd7954.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1954fdc9927d4f6bb752e881f18e62ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5c180d619dbd4402b578400f63047bcf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/2bda9df91577488aaee012dc4cef76dd.png">
<meta property="article:published_time" content="2021-07-24T05:10:15.000Z">
<meta property="article:modified_time" content="2022-06-15T16:09:37.028Z">
<meta property="article:author" content="Tr0e">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/7864997cd6394c49993d994ea0b43ae9.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Tr0e"><img width="96" loading="lazy" src="/images/Tr0e.jpg" alt="Tr0e"></a><div class="site-author-name"><a href="/about/">Tr0e</a></div><span class="site-name">Cyber Security</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/about/" title="About Me" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">Java反序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">源码审计分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA-%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">IDEA 部署环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">序列化过程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">反序列化的分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://tr0e.github.io/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BShiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Tr0e"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Cyber Security"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JAVA代码审计之Shiro反序列化漏洞分析</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2021-07-24 13:10:15" itemprop="dateCreated datePublished" datetime="2021-07-24T13:10:15+08:00">2021-07-24</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">漏洞分析</span></a></span></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的一篇文章：<a target="_blank" rel="noopener" href="https://bwshen.blog.csdn.net/article/details/109269859">Apache Shiro Java反序列化漏洞复现</a> 曾介绍了 CVE-2016-4437 漏洞的复现过程和利用方式，为了不再当个“脚本小子”工具人…本文将记录学习下从源码审计的角度分析 CVE-2016-4437 漏洞的原理。</p>
<h1 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h1><p>同样的在前面一篇博文：<a target="_blank" rel="noopener" href="https://bwshen.blog.csdn.net/article/details/82051781">Java-序列化与反序列化</a> 已经讲述了 Java 序列化和反序列化的概念，此处简单再描述下。</p>
<p>把对象转换为字节序列的过程称为对象的序列化；把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>对象的序列化主要有两种用途：</p>
<ol>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中（持久化对象）；</li>
<li>在网络上传送对象的字节序列（网络传输对象）。</li>
</ol>
<p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为 Java 对象。 </p>
<p><strong>Java序列化实例</strong></p>
<p>来看一个实际的例子：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Serializable</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>上述代码定义了 People 类，并且实现了 Serializable 接口，我们便可以对其进行序列化和反序列化操作：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 初始化对象</span>
        <span class="token class-name">People</span> people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        people<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"xiaoming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        people<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 序列化步骤</span>
        <span class="token comment">// 1. 创建一个ObjectOutputStream输出流</span>
        <span class="token comment">// 2. 调用ObjectOutputStream对象的writeObject输出可序列化对象</span>
        <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"d:/People.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>people<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"people对象序列化成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 反序列化步骤</span>
        <span class="token comment">// 1. 创建一个ObjectInputStream输入流</span>
        <span class="token comment">// 2. 调用ObjectInputStream对象的readObject()得到序列化的对象</span>
        <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"d:/People.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">People</span> people1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">People</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"people对象反序列化成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>people1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>people1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>代码运行结果：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">people对象序列化成功！
people对象反序列化成功！
xiaoming
<span class="token number">18</span></code></pre>
<p>序列化过程将字节流保存在 d:/People.txt 中，我们可以在 d:/People.txt 看到序列化后的二进制对象（其中开头的 aced 0005 是 Java 序列化文件的文件头）：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/7864997cd6394c49993d994ea0b43ae9.png" alt="在这里插入图片描述" loading="lazy"><br><strong>反序列化漏洞</strong></p>
<p>回想一下 CTF 比赛经常遇到的 PHP 的反序列化漏洞，反序列化对象时会调用类的魔法函数<code>__construct()</code>(创建对象时触发)，我们可以构造 pop 链来控制(改造)<code>__construct()函</code>数，从而反序列化时执行我们需要的操作，Java 也是类似。</p>
<p>在上面的代码中，我们通过调用 readObject() 方法来从一个源输入流中读取字节序列，再把它们反序列化为一个对象，那么我们如果控制了此类的 readObject() 方法会怎么样？为了验证想法，我们修改一下 People 类，重写其 readObject() 方法：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//添加以下方法，重写People类的readObject()方法</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectInputStream</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">&#123;</span>
        <span class="token comment">//执行默认的readObject()方法</span>
        in<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//执行打开计算器程序命令</span>
        <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"calc.exe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>运行程序，当执行<code>People people1 = (People) ois.readObject();</code>语句时会调用 People 类的 readObject 方法，弹出计算器：<br><img src="https://img-blog.csdnimg.cn/ca674bfe48434e1c89d6f1e104675912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">由此可知控制了类的 readObject 方法便可以在反序列化该类时执行任意操作。事实上大多数 Java 反序列化漏洞都可追溯到 readObject 方法，通过构造 pop 链最终改造 readObject() 方法。</p>
<h1 id="源码审计分析"><a href="#源码审计分析" class="headerlink" title="源码审计分析"></a>源码审计分析</h1><p>Apache Shiro 是一个Java安全框架，执行身份验证、授权、密码和会话管理。2016年网络中曝光 Apache Shiro 1.2.4 以前的版本存在反序列化漏洞，尽管该漏洞已经曝光几年，但是在实战中仍然比较实用。</p>
<p><strong>影响版本</strong></p>
<p>Apache Shiro &lt;= 1.2.4</p>
<p><strong>漏洞原理</strong></p>
<p>Apache Shiro 框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的Cookie。Cookie 的 key 为 RememberMe，Cookie 的值是经过对相关信息进行序列化，然后使用AES加密，最后在使用 Base64 编码处理形成的。</p>
<p>在服务端接收 Cookie值时，按照如下步骤来解析处理：</p>
<ol>
<li>检索 RememberMe cookie 的值；</li>
<li>Base 64解码；</li>
<li>使用AES解密(加密密钥硬编码)；</li>
<li>进行反序列化操作（未作过滤处理）。</li>
</ol>
<p>在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。</p>
<h2 id="IDEA-部署环境"><a href="#IDEA-部署环境" class="headerlink" title="IDEA 部署环境"></a>IDEA 部署环境</h2><p>下面在本地 IDEA 部署 Apache Shrio 1.2.4 漏洞环境，以便于进行漏洞动态调试分析。</p>
<p>1、首先在 Github 下载项目源码：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>apache<span class="token operator">/</span>shiro</code></pre>
<p>注意选择存在漏洞的 1.2.4 版本：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/f552f24c972241e190ad106a30e9c184.png" alt="在这里插入图片描述" loading="lazy">2、编辑 <code>shiro\samples\web</code> 路径下的 pom.xml 文件，给 jstl 指定版本：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/ee6b526e63584954b66d4b812c8fd643.png" alt="在这里插入图片描述" loading="lazy">3、使用 IDEA 导入此 MVN 项目：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/b4c3ce063ade41d2816be118b27ae603.png" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/d6649bdbd90e4ab68117bcee444c8ba6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">4、等待 IDEA 自动下载并导入完项目依赖的包，build 完成后项目结构如下：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/c80d0dee92f343598408ae429166095b.png" alt="在这里插入图片描述" loading="lazy">注意，pom.xml 里面的配置会让程序自动下载<code>shiro-core</code>依赖包（后面程序加断点调试会用到该部分文件）：<br><img src="https://img-blog.csdnimg.cn/8089e47848bc4c99998997e9647c07f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>5、接着设置 <code>run/debug configurations</code>， 添加本地 Tomcat 环境（需要提前在本地安装 Tomcat 环境）：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/cf6e74b611ee4d9cb442d6cb580011d7.png" alt="在这里插入图片描述" loading="lazy"> 6、添加项目 War 包 <code>samples-web.war</code>进 Tomcat 中：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/eb7193051ac649e1a84754c95304456e.png" alt="在这里插入图片描述" loading="lazy">附：此处该 War 包之所以存在，是因为它也是前面 pom.xml 配置文件设置的自动下载到本地的：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/cdee004cf6cc482eba35cf2029829ebb.png" alt="在这里插入图片描述" loading="lazy">7、配置完以上的准备工作，就可以直接 run 运行程序了：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/f788bd07bf114fd08b52ea1da27eaefc.png" alt="在这里插入图片描述" loading="lazy">运行成功后浏览器将自动打开目标程序站点，本地环境部署至此结束：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/4b28af311e8e4422a486991775d6023a.png" alt="在这里插入图片描述" loading="lazy">8、访问登录页面进行已提示账户的登录，抓包可见 remenberme 字段：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/f79e66769e594faa87b260f0725df38b.png" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/c0f1974110a74d63bc812fce292f154d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">9、为了开始调试该程序，先停止程序运行，然后在 <code>External Libraries</code> 中找到 shiro-core-1.2.4 的 jar 包，打开 <code>RememberMeManager.class</code> 文件并在 onSuccessfulLogin 函数前加断点，然后点击 Debug 按钮开始在调试模式下运行程序：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/1f6bce5bdc5d4d7aaa92dfebf54830b4.png" alt="在这里插入图片描述" loading="lazy">10、接着在 Web 端登录账户 root/secret，勾选上 Remember Me 的按钮，程序会停在断点处，然后便可以开始正式的 Debug 漏洞调试了：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/40edf49ee666483d97e9861c30622bef.png" alt="在这里插入图片描述" loading="lazy"><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/49e7f80fd6ce484f95158dd51abaf9ec.png" alt="在这里插入图片描述" loading="lazy">11、以上项目工程相当于是只导入 samples-web 文件夹，实际上也可以直接在 IDEA 导入在 Github 下载的完整的 shiro-shiro-root-1.2.4 源码工程文件夹，待 Build 自动下载完所需的依赖包后，同样的步骤配置 Tomcat，然后直接找到 core 文件夹下的<code>RememberMeManager.java</code> 文件并在 onSuccessfulLogin 函数前加断点：<br> <img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/8c8581e57bfc4cf4a3a590089e423dc2.png" alt="在这里插入图片描述" loading="lazy">12、接着在 Debug 模式下运行程序，也可在断点处拦截程序、进行调试：<br> <img src="https://img-blog.csdnimg.cn/753d1bdd3c3644d4914a7b3969045cad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">后面的审计分析将基于上述导入所有项目源码的工程项目，因为相比于第一种仅导入 samples-web 文件夹并通过引入shiro-core-1.2.4 的 jar 包来调试 class 文件的方式，直接审计全部 java 源码将更为直观！</p>
<h2 id="序列化过程分析"><a href="#序列化过程分析" class="headerlink" title="序列化过程分析"></a>序列化过程分析</h2><p>下面开始正式调试分析 Apache Shiro 框架在登录过程生成序列化 Cookie对象的过程。</p>
<p>1、首先看下登录请求发送后断点停留的 onSuccessfulLogin 函数：<br><img src="https://img-blog.csdnimg.cn/73acb23c58e942b2a4174e836af67d72.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">程序首先调用 forgetIdentity 构造方法处理 request 和 response 请求，包括在 response 中加入 cookie 信息，然后调用 rememberIdentity 函数，来处理 cookie 中的 rememberme 字段。</p>
<p>2、我们按 F8 来 Step Over 跨过 forgetIdentity 构造方法，然后 F7 来 Step Into 跟进下 rememberIdentity 函数：<br><img src="https://img-blog.csdnimg.cn/7b9609bc8adf4325a52de6451724f51a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">可以看到，rememberIdentity 函数首先调用 getIdentityToRemember 函数来获取用户身份，这里也就是”root”。</p>
<p>3、接着我们跟进 rememberIdentity 构造方法：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5ec3cf0b782b4ba3a3b642278df1e5d8.png" alt="在这里插入图片描述" loading="lazy">4、上面调用了 convertPrincipalsToBytes 方法将 accountPrincipals 也就是 “root” 转换为字节形式，跟进该方法查看内部如何转换：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/235318db40574f69b13b717c0b237349.png" alt="在这里插入图片描述" loading="lazy">5、转换过程是先序列化用户身份 “id” ，再对其进行 encrypt 加密，进一步跟进 encrypt 函数查看加密方式：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/9ee4baad44f2416da5451a6524e52e55.png" alt="在这里插入图片描述" loading="lazy">6、encrypt 函数就是调用 AES 加密对序列化后的 “root” 进行加密，加密的密钥由 getEncryptionCipherKey() 得到，跟进 getEncryptionCipherKey() 函数会发现其值为常量（即密钥硬编码）：<br><img src="https://img-blog.csdnimg.cn/4d14b8f6eb544b69a856d7bf5fa0bb23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">7、Shift+F8 进行 Step Out 步出，返回到 rememberIdentity 函数：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/459933640c3549a080b7432e8521c9d5.png" alt="在这里插入图片描述" loading="lazy"><br>8、跟进 rememberSerializedIdentity 函数查看后续转换流程，发现该函数对上述 root 的 AES 加密后的序列化值进行 base64 编码后，设置到cookie中：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/d13228bd3a264e1287453b0de327720b.png" alt="在这里插入图片描述" loading="lazy">到这里我们可以梳理下上述整个 Cookie 的生成过程，当我们勾选上  Remember Me 选项框后，以 root 身份登录，后端会进行如下操作：</p>
<ol>
<li>序列化用户身份”root”，得到值 A；</li>
<li>对 root 的序列化值 A 进行 AES 加密（密钥为硬编码的常量），得到值 B；</li>
<li>base64 编码上述计算的结果 B，得到值 C；</li>
<li>将值 C 设置到 response 响应包中 cookie 的 rememberme 字段。</li>
</ol>
<p>可以看看整个数据包：<br><img src="https://img-blog.csdnimg.cn/c0f1974110a74d63bc812fce292f154d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="反序列化的分析"><a href="#反序列化的分析" class="headerlink" title="反序列化的分析"></a>反序列化的分析</h2><p>以上已经调试分析完 Shiro 生成 Cookie 字段的序列化、加密过程，下面来进一步调试分析下 Cookie 字段的反序列化、解密过程。</p>
<p>1、将断点打在<code>org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity</code>函数处，然后发送一个带有 rememberMe Cookie 的请求：<br><img src="https://img-blog.csdnimg.cn/c79e5406d7b048ebb5d9de0d510891c4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>2、跟进查看 getRememberedPrincipals 函数：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/98fbc3183ad44157988686ebaf712d1e.png" alt="在这里插入图片描述" loading="lazy"><br>3、跟进 getRememberedSerializedIdentity 函数，发现函数提取出 cookie 并将其进行 base64 解码：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/db03f21566644232a1e5420734c5e4d9.png" alt="在这里插入图片描述" loading="lazy">4、Step Out 返回到 getRememberedPrincipals 函数，继续跟进到 convertBytesToPrincipals 函数，发现其对 cookie 进行 AES 解密和反序列化：<br><img src="https://img-blog.csdnimg.cn/31849a60ffb8441fac6c7199067c817a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">5、同理再依次跟进查看 AES 解密函数 decrypt、反序列化函数 deserialize，如下：<br><img src="https://img-blog.csdnimg.cn/9b205fc0ff9040a5a303c10108d05f22.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/6bf234c7443b44018c5764741dfd18e1.png" alt="在这里插入图片描述" loading="lazy">至此 Cookie 的反序列化、解密流程分析完毕，整个流程大致为：</p>
<ol>
<li>读取 cookie 中 rememberMe 值；</li>
<li>base64 解码；</li>
<li>AES解密；</li>
<li>反序列化</li>
</ol>
<p>其中 AES 加解密的密钥为常量 且 反序列化过程没有进行过滤，于是我们可以手动构造 rememberMe 值，改造其 readObject() 方法，让其在反序列化时执行任意操作。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>在前面的一篇文章：<a target="_blank" rel="noopener" href="https://bwshen.blog.csdn.net/article/details/109269859">Apache Shiro Java反序列化漏洞复现</a> 已经介绍了如何手工构造 Payload 对此处的反序列化漏洞进行利用，下面简单演示下利用  <a target="_blank" rel="noopener" href="https://github.com/j1anFen/shiro_attack">shiro_attack-2.0</a> 工具进行自动化攻击。</p>
<p>1、如下图，依次爆破密钥和检测构造链：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/a010bff13b0b4b16ae6f17b8838f26f1.png" alt="在这里插入图片描述" loading="lazy">2、利用反序列化漏洞成功执行任意命令：<br><img src="https://img-blog.csdnimg.cn/e0a5b4279a5340789275c33fdf779f2c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>【注意】 如果是直接导入 samples-web 文件夹建立工程项目的话，会导致攻击失败：<br><img src="https://img-blog.csdnimg.cn/66f00111e73442ad867148b25cb8557b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>因为 shiro550 自带的包是 commons-collections3.2.1，原生情况下直接用 ysoserial 打，是不会成功的（这是因为 CommonsCollections3.2.1 用的是非数组形式的利用链，在该利用链上没有出现数组类型的对象，这使得在 shiro 的环境下，可以正确执行命令）：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5681c04849a64475b429b126f9cd7954.png" alt="在这里插入图片描述" loading="lazy"><br>需要修改 pom.xml，添加 commons-collections4 依赖包：<br><img src="https://img-blog.csdnimg.cn/1954fdc9927d4f6bb752e881f18e62ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">重新 Build 一下项目，确认已下载上述依赖包：<br><img src="https://img-blog.csdnimg.cn/5c180d619dbd4402b578400f63047bcf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5MDg5Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>随后即可成功攻击利用：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/2bda9df91577488aaee012dc4cef76dd.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文是调试分析 CVE 漏洞的第一篇，遇到了很多坑点，但也学到了不少东西，继续努力吧！</p>
<p>最后说一下，CVE-2016-4437 漏洞主要的修复方案：</p>
<ol>
<li>升级 shiro 到最新版本；</li>
<li>如果在配置里配置了密钥，那么请一定不要使用网上的密钥， 一定不要！请自己base64一个AES的密钥，或者利用官方提供的方法生成密钥：org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey()。</li>
</ol>
<p>本文参考文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://saucer-man.com/information_security/396.html">分析调试apache shiro反序列化漏洞(CVE-2016-4437)</a>；</li>
<li><a target="_blank" rel="noopener" href="http://www.lmxspace.com/2019/10/17/Shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%B0%E5%BD%95/">Shiro 反序列化记录 </a>。</li>
</ol>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Tr0e</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://tr0e.github.io/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BShiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="JAVA代码审计之Shiro反序列化漏洞分析">https://tr0e.github.io/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BShiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A0%B4%E8%A7%A3AliCrackme%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E5%AF%B9%E6%8A%97/" rel="prev" title="IDA动态调试破解AliCrackme与反调试对抗"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">IDA动态调试破解AliCrackme与反调试对抗</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/%E5%9F%BA%E4%BA%8EFRP%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%94%BB%E5%87%BB/" rel="next" title="基于FRP反向代理工具实现内网穿透攻击"><span class="post-nav-text">基于FRP反向代理工具实现内网穿透攻击</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Tr0e</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.2</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.4</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>