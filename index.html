<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Blog of Tr0e</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Blog of Tr0e">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Blog of Tr0e">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Tr0e">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Blog of Tr0e" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog of Tr0e</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-WebSocket通信协议基础原理与潜在安全威胁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/12/WebSocket%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BD%9C%E5%9C%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/" class="article-date">
  <time datetime="2022-06-12T08:43:56.165Z" itemprop="datePublished">2022-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/12/WebSocket%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BD%9C%E5%9C%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/">WebSocket通信协议基础原理与潜在安全威胁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目上遇到了一个 Web 系统和本地 PC 的 exe 客户端程序采用了 WebSocket 通信，exe 客户端程序做了登录、鉴权机制并采用 HTTPS 协议与后台微服务进行通信。由于原来没有了解过 WebSocket，所以一开始上来也比较懵，接着学习了下 WebSocket 的原理和攻击模式，竟然发现一个严重漏洞——该 Web 系统虽然也做了登录控制，但是与 exe 程序之间的 WebSocket 却没做鉴权机制……这直接导致攻击者可以绕过 Web 系统和 exe 程序本身的鉴权机制，直接通过 Web 系统 WebScoket 的通信方式来实现对后台业务服务器资源数据的未授权访问。<br><img src="https://img-blog.csdnimg.cn/b3f216feae7845edb4d56d8d65da84f4.png" alt="在这里插入图片描述"><br>本文来记录学习下 WebSocket 全双工通信的基本原理与鉴权机制，并分析 WebSocket 常见的安全风险。</p>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket 和 HTTP 一样，也是一种通讯协议，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<h2 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h2><p>有很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出 HTTP 请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而 HTTP 请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p>
<p>WebSocket 协议是从 HTML5 开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。它能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。<br><img src="https://img-blog.csdnimg.cn/4a7fe1ac3a5649ac9b3413233d86a22c.png" alt="在这里插入图片描述"><br>WebSocket 是真正意义上的全双工模式，也就是我们俗称的「长连接」。当完成握手连接后，客户端和服务端均可以主动的发起请求，回复响应，并且两边的传输都是相互独立的。</p>
<p>以一个通俗的场景来理解下 HTTP 协议与 WebSocket 协议的差异：</p>
<p><strong>（1）HTTP 小场景（模拟 ajax 轮询）</strong></p>
<ul>
<li>客户端：啦啦啦，有没有新信息（Request）</li>
<li>服务端：没有（Response）</li>
<li>客户端：啦啦啦，有没有新信息（Request）</li>
<li>服务端：没有。。（Response）</li>
<li>客户端：啦啦啦，有没有新信息（Request）</li>
<li>服务端：你好烦啊，没有啊。。（Response）</li>
</ul>
<p><strong>（2）WebSocket 小场景（模拟全双工）</strong></p>
<ul>
<li>客户端：啦啦啦，有没有新信息（Request）</li>
<li>服务端：额。。没有（Response）</li>
<li>客户端：啦啦啦，有没有新信息（Request）</li>
<li>服务端：你个烦人精，有消息的时候我会主动发给你的（Response）</li>
<li>服务端：烦人精，你要的信息来了（Response）……</li>
</ul>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>WebSocket 的数据传输，是基于 TCP 协议，但是在传输之前，还有一个握手的过程，双方确认过眼神，才能够正式的传输数据。WebSocket 的握手过程，符合其 “Web” 的特性，是利用 HTTP 本身的 “协议升级” 来实现。</p>
<p>在建立连接前，客户端还需要知道服务端的地址，WebSocket 并没有另辟蹊径，而是沿用了 HTTP 的 URL 格式，但协议标识符变成了 “ws” 或者 “wss”，分别表示明文和加密的 WebSocket 协议，这一点和 HTTP 与 HTTPS 的关系类似。<br><img src="https://img-blog.csdnimg.cn/71c6d2ec276c4fed8cd27db267ec332c.png" alt="在这里插入图片描述"><br>以下是一些 WebSocket 的 URL 例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ws</span>:<span class="comment">//cxmydev.com/some/path</span></span><br><span class="line"><span class="attr">ws</span>:<span class="comment">//cxmydev.com:8080/some/path</span></span><br><span class="line"><span class="attr">wss</span>:<span class="comment">//cxmydev.com:443?uid=xxx</span></span><br></pre></td></tr></table></figure>
<p>为了创建 Websocket 连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”。</p>
<p><strong>实现步骤：</strong></p>
<p>1、发起请求的浏览器端，发出协商报文：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /chat <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: server.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//example.com</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat, superchat</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>具体字段含义：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/2707218303e749999fdacdba3096436f.png" alt="在这里插入图片描述"><br>里面的核心字段：</p>
<ul>
<li>Connection: Upgrade 以及 Upgrade: websocket 这个就是告诉服务器，下一步我要对协议进行升级了，升级到 WebSocket；</li>
<li>Sec-WebSocket-Key 是由浏览器随机生成的字符串的 Base64 编码，提供基本的防护，防止恶意或者无意的连接。</li>
</ul>
<p>2、服务器端响应 101 状态码（即切换到socket通讯方式），其报文：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">101</span> <span class="title class_">Switching</span> <span class="title class_">Protocols</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat</span><br></pre></td></tr></table></figure>
<p>一行行来解释上面服务端的响应的含义：</p>
<ul>
<li>首先，101 状态码表示服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求；</li>
<li>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key；</li>
<li>最后，Sec-WebSocket-Protocol 则是表示最终使用的协议。</li>
</ul>
<p>其中 Sec-WebSocket-Accept 的计算方法：</p>
<ul>
<li>将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；</li>
<li>通过 SHA1 计算出摘要，并转成 base64 字符串，伪代码为：<code>toBase64(sha1(Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ))</code></li>
</ul>
<p>注意：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，<strong>但连接是否安全、数据是否安全、客户端 / 服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证</strong>。</p>
<p>一旦服务器端返回 101 响应，即可完成 WebSocket 协议切换。服务器端可以基于相同端口，将通信协议从 http:// 或 https:// 切换到 ws://或 wss://。协议切换完成后，浏览器和服务器端可以使用 WebSocket API 互相发送和收取文本和二进制消息。</p>
<p>而在连接建立后，WebSocket 采用二进制帧的形式传输数据，其中常用的包括用于数据传输的数据帧 MESSAGE 以及 3 个控制帧：</p>
<ul>
<li>PING：主动保活的 PING 帧；</li>
<li>PONG：收到 PING 帧后回复；</li>
<li>CLOSE：主动关闭 WebSocket 连接。</li>
</ul>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>下面使用 Python 来编写 WebSocket 通信的示例程序。Python websockets是用于在 Python 中构建 WebSocket 服务器和客户端的库，它基于 asyncio 异步 IO 建立，提供基于协程的 API。</p>
<p><strong>1、服务端 Server.py</strong></p>
<p>用于构建 websocket 服务器，在本地 8765 端口启动，会将接收到的消息加上 <code>I got your message:</code> 返回回去。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">websocket, path</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:</span><br><span class="line">        message = <span class="string">&quot;I got your message: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(message)</span><br><span class="line">        <span class="keyword">await</span> websocket.send(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(websockets.serve(echo, <span class="string">&#x27;localhost&#x27;</span>, <span class="number">8765</span>))</span><br><span class="line">    asyncio.get_event_loop().run_forever()</span><br></pre></td></tr></table></figure>
<p><strong>2、客户端Client.py</strong></p>
<p>跟指定 url 建立 websocket 连接，并发送消息，然后等待接收消息，并将消息打印出来。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">uri</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> websockets.connect(uri) <span class="keyword">as</span> websocket:</span><br><span class="line">        <span class="keyword">await</span> websocket.send(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        recv_text = <span class="keyword">await</span> websocket.recv()</span><br><span class="line">        <span class="built_in">print</span>(recv_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(hello(<span class="string">&#x27;ws://localhost:8765&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>先执行 Server.py，再执行 Client.py，客户端的输出结果如下：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/9c2656e1ac674f7fa745c20f52a01818.png" alt="在这里插入图片描述"><br><strong>3、服务端主动发送消息</strong></p>
<p>上面的示例未实现服务端主动给客户端发送消息的全双工通信，下面来完善下代码，当建立连接之后，客户端可以随时接收服务器发来的消息。服务器可以依据逻辑，给客户端推送指定消息。服务器和客户端代码会有一点变化，在服务器回完第一条消息之后，开始轮询时间，当秒数达到0的时候，会主动给客户端回一条消息。</p>
<p>Server.py：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">websocket, path</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:</span><br><span class="line">        message = <span class="string">&quot;I got your message: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(message)</span><br><span class="line">        <span class="keyword">await</span> websocket.send(message)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            t = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(t).endswith(<span class="string">&quot;0&quot;</span>):</span><br><span class="line">                <span class="keyword">await</span> websocket.send(t)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(websockets.serve(echo, <span class="string">&#x27;localhost&#x27;</span>, <span class="number">8765</span>))</span><br><span class="line">    asyncio.get_event_loop().run_forever()</span><br></pre></td></tr></table></figure>
<p>Client.py：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">uri</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> websockets.connect(uri) <span class="keyword">as</span> websocket:</span><br><span class="line">        <span class="keyword">await</span> websocket.send(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&lt; Hello world!&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            recv_text = <span class="keyword">await</span> websocket.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(recv_text))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(hello(<span class="string">&#x27;ws://localhost:8765&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>先执行 Server.py，再执行 Client.py，客户端的输出结果如下：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/5105f4b999e04e4caabf65481806ad36.png" alt="在这里插入图片描述"><br>最后一条消息则是服务端主动给客户端发送的。</p>
<h2 id="Burp抓包"><a href="#Burp抓包" class="headerlink" title="Burp抓包"></a>Burp抓包</h2><p><strong>1、在浏览器上使用 WebSocket</strong></p>
<p>如何在前端发送 Websocket 请求呢？看这段代码 Client.html，先建立连接，然后向服务端发送 Hello world，然后把接收到的所有消息依次展示出来。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>websocket通信客户端<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.5.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">WebSocketTest</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (<span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://127.0.0.1:8765&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 连接建立后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">                ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="language-javascript">                    ws.<span class="title function_">send</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    $(<span class="string">&quot;#main&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;&lt;p&gt;&quot;</span> + <span class="string">&quot;&lt;=&quot;</span> + <span class="string">&quot;Hello world!&quot;</span> + <span class="string">&quot;&lt;/p&gt;&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 接收到服务器消息后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">                ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> received_msg = evt.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (received_msg.<span class="title function_">indexOf</span>(<span class="string">&quot;sorry&quot;</span>) == -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        $(<span class="string">&quot;#main&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;&lt;p&gt;&quot;</span> + <span class="string">&quot;=&gt;&quot;</span> + received_msg + <span class="string">&quot;&lt;/p&gt;&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 连接关闭后的回调函数</span></span></span><br><span class="line"><span class="language-javascript">                ws.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&quot;连接已关闭...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;您的浏览器不支持 WebSocket!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;WebSocketTest()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击 PyCharm 提供的如下按钮在浏览器打开上述 HTML 文件：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/0352ce88034a40c2932c5c59331d746f.png" alt="在这里插入图片描述"><br>程序运行效果如下图：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/584730448454415fae5cf63c3674d99d.png" alt="在这里插入图片描述"><br><strong>2、BurpSuite 观察 WebSocket 报文</strong></p>
<p>这上面的示例程序运行过程中，使用 BurpSuite 抓包观察，可以在 HTTP history 看到建立 WebSocket 的握手过程：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/0022ce2a71f9481da29247ee8bdfab02.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/eed1f4cfee6748a79d0ce185e6225929.png" alt="在这里插入图片描述"><br>同时可以在 WebSocket history 看到客户端与服务端的通信过程：<br><img src="https://img-blog.csdnimg.cn/09c3d16e28204ab09c2aabaf35f0a98c.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/e681a67164844e6ba80c4704bd090374.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/e89b2b0fb22d4d3a8bc7fb4cecceba7e.png" alt="在这里插入图片描述"></p>
<p>可以将第一个会话 Hello World 发送到 Repeater 进行重放，效果如下：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/a0b4a2ce5e3f489aa56ff90cae4c8323.png" alt="在这里插入图片描述"><br>同时上述重放会触发浏览器也同步更新：<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/a44493dbe68e4864ba08da32bc4b8762.png" alt="在这里插入图片描述"></p>
<h1 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h1><p>上文讨论完 WebSocket 的基本概念和用法后，下面来讨论下 WebSocket 所面临的安全威胁。</p>
<h2 id="鉴权缺失"><a href="#鉴权缺失" class="headerlink" title="鉴权缺失"></a>鉴权缺失</h2><p>从上面的示例程序中，读者应该发现了上述程序的服务端和客户端并未存在鉴权机制，谁都可以向服务端发起连接，如果服务端提供的接口包含敏感数据或业务功能，那么后果可想而知……</p>
<p>WebSocket 协议没有规定服务器在握手阶段应该如何认证客户端身份。服务器可以采用任何 HTTP 服务器的客户端身份认证机制，如 cookie 认证，HTTP 基础认证，TLS 身份认证等。在 WebSocket 应用认证实现上面临的安全问题和传统的 Web 应用认证是相同的，如：</p>
<ol>
<li>CVE-2015-0201：Spring 框架的 Java SockJS 客户端生成可预测的会话ID，攻击者可利用该漏洞向其他会话发送消息;；</li>
<li>CVE-2015-1482：Ansible Tower 未对用户身份进行认证，远程攻击者通过 Websocket 连接获取敏感信息。</li>
</ol>
<p>所谓鉴权，其实就是为了安全考虑，避免服务端启动 WebSocket 的连接服务后，任谁都可以连接，这肯定会引发一些安全问题。其次，服务端还需要将 WebSocket 的连接实体与一个真实的用户对应起来，否则业务就无法保证了。</p>
<p>前文提到，WebSocket 在握手阶段，使用的是 HTTP 的 “协议升级”，它本质上还是 HTTP 的报文头发送一些特殊的头数据，来完成协议升级。那么实际我们在 WebSocket 握手阶段，也可以通过 Header 传输一些鉴权的数据，例如 uid、token 之类，具体方法：</p>
<ol>
<li>方案A：在握手阶段返回 Response 响应包的时候，为其 Header 增加鉴权字段传递给客户端 ；</li>
<li>方案B：部分业务功能集成了 WebSocket 协议的 Web 系统已单独有授权机制并已颁发 Token，那么在触发 WeSocket 业务功能时携带该 Token 进行后台校验。</li>
</ol>
<p>随后的 WebSocket 通信的的 URL 需要携带鉴权参数来防着未授权访问，比如如下的鉴权参数 token：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wss://example.com?uid=xxx&amp;token=xxx</span><br></pre></td></tr></table></figure>
<p>与此同时，同鉴权缺失的风险一样，WebSocket 协议没有指定任何授权方式，应用程序中用户资源访问等的授权策略由服务端或开发者实现。WebSocket 应用也会存在和传统 Web 应用相同的安全风险，如：<strong>垂直权限提升和水平权限提升</strong>。</p>
<p>最后附上一个用于建立 WSS 协议链接且携带 JSON 格式数据的攻击测试脚本：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">msg = &#123;</span><br><span class="line">    <span class="string">&quot;method&quot;</span>: <span class="string">&quot;SUBSCRIBE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: [<span class="string">&quot;!bookTicker&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">call_api</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> websockets.connect(<span class="string">&#x27;wss://127.0.0.1:8765/ws&#x27;</span>) <span class="keyword">as</span> websocket:</span><br><span class="line">        <span class="keyword">await</span> websocket.send(msg)</span><br><span class="line">        <span class="keyword">while</span> websocket.<span class="built_in">open</span>:</span><br><span class="line">            response = <span class="keyword">await</span> websocket.recv()</span><br><span class="line">            <span class="comment"># do something with the response...</span></span><br><span class="line">            <span class="built_in">print</span>(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(call_api(json.dumps(msg)))</span><br></pre></td></tr></table></figure>

<h2 id="劫持漏洞"><a href="#劫持漏洞" class="headerlink" title="劫持漏洞"></a>劫持漏洞</h2><p>WebSocket 使用基于源的安全模型，在发起 WebSocket 握手请求时，浏览器会在请求中添加一个名为 Origin 的 HTTP 头，Oringin 字段表示发起请求的源，以此来防止未经授权的跨站点访问请求。WebSocket 的客户端不仅仅局限于浏览器，因此 WebSocket 规范没有强制规定握手阶段的 Origin 头是必需的，并且 WebSocket 不受浏览器同源策略的限制。</p>
<p><strong>如果服务端没有针对 Origin 头部进行验证可能会导致跨站点 WebSocket 劫持攻击</strong>。该漏洞最早在 2013 年被Christian Schneider 发现并公开，Christian 将之命名为跨站点 WebSocket 劫持 (Cross Site WebSocket Hijacking)(CSWSH)。跨站点 WebSocket 劫持危害大，但容易被开发人员忽视。相关案例可以参考: IPython Notebook(CVE-2014-3429)、OpenStack Compute(CVE-2015-0259)、Zeppelin WebSocket 服务器等跨站 WebSocket 劫持。<br><img src="https://img-blog.csdnimg.cn/32155a732b7746b88550f68b27bf5354.png" alt="在这里插入图片描述"><br>上图展示了跨站 WebSocket 劫持的过程，某个用户已经登录了 WebSocket 应用程序，如果他被诱骗访问了某个恶意网页，而恶意网页中植入了一段 js 代码，自动发起 WebSocket 握手请求跟目标应用建立 WebSocket 连接。注意到，Origin 和 Sec-WebSocket-Key 都是由浏览器自动生成的，浏览器再次发起请求访问目标服务器会自动带上Cookie 等身份认证参数。如果服务器端没有检查 Origin头，则该请求会成功握手切换到 WebSocket 协议，<strong>恶意网页就可以成功绕过身份认证连接到 WebSocket 服务器，进而窃取到服务器端发来的信息，或者发送伪造信息到服务器端篡改服务器端数据</strong>。与传统跨站请求伪造(CSRF)攻击相比，CSRF 主要是通过恶意网页悄悄发起数据修改请求，而跨站 WebSocket 伪造攻击不仅可以修改服务器数据，还可以控制整个双向通信通道。也正是因为这个原因，Christian 将这个漏洞命名为劫持(Hijacking)，而不是请求伪造(Request Forgery)。</p>
<p>理解了跨站 WebSocket 劫持攻击的原理和过程，那么如何防范这种攻击呢？处理也比较简单，在服务器端的代码中增加对 Origin 头的检查，如果客户端发来的 Origin 信息来自不同域，服务器端可以拒绝该请求。但是仅仅检查 Origin 仍然是不够安全的，恶意网页可以伪造 Origin 头信息，绕过服务端对 Origin 头的检查，更完善的解决方案可以借鉴 CSRF 的解决方案-令牌机制。</p>
<h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p>WebSocket 设计为面向连接的协议，可被利用引起客户端和服务器端拒绝服务攻击，相关案例可参考: F5 BIG-IP 远程拒绝服务漏洞(CVE-2016-9253)。</p>
<p><strong>1、客户端拒绝服务</strong></p>
<p>WebSocket 连接限制不同于 HTTP 连接限制，和 HTTP 相比，WebSocket 有一个更高的连接限制，不同的浏览器有自己特定的最大连接数,如：火狐浏览器默认最大连接数为 200。通过发送恶意内容，用尽允许的所有 Websocket 连接耗尽浏览器资源，引起拒绝服务。</p>
<p><strong>2、服务器端拒绝服务</strong></p>
<p>WebSocket 建立的是持久连接，只有客户端或服务端其中一发提出关闭连接的请求，WebSocket 连接才关闭，因此攻击者可以向服务器发起大量的申请建立 WebSocket 连接的请求，建立持久连接，耗尽服务器资源，引发拒绝服务。针对这种攻击，可以通过设置单 IP 可建立连接的最大连接数的方式防范。</p>
<h2 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h2><p>WebSocket 应用和传统 Web 应用一样，都需要对输入进行校验，来防范来客户端的 XSS 攻击，服务端的 SQL 注入，代码注入等攻击。</p>
<p>来看一个靶场，点开靶场，我们移步到 Live Chat 的界面。<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/76c94431d9dc4c95848c3804bf094c00.png" alt="在这里插入图片描述"><br>先抓包，接着发送一条数据，并在 WebSockets History 中查看数据，修改包，构造成 XSS 的 POC。<br><img src="https://img-blog.csdnimg.cn/2d84079443644e7899998326ef6e44d0.png" alt="在这里插入图片描述"><br>发包，再回到 Web 界面的时候成功实现 XSS。<br><img src="https://raw.githubusercontent.com/Tr0e/PiCGo/main/img/078d3663863c45dd8e23a618b5d3811a.png" alt="在这里插入图片描述"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>WebSocket 是一个基于 TCP 的 HTML5 的新协议，可以实现浏览器和服务器之间的全双工通讯。在即时通讯等应用中，WebSocket 具有很大的性能优势，并且非常适合全双工通信，但是和任何其他技术一样，开发 WebSocket 应用也需要考虑潜在的安全风险。</p>
<p>基于 WebSocket 的一系列漏洞的防御措施：</p>
<ol>
<li>使用 wss 协议（WebSockets over TLS），防止中间人攻击；</li>
<li>通过设置 Cookie、Token 等鉴权字段来对 WebSockets 进行鉴权，纺防止未授权漏洞；</li>
<li>校验 Origin 字段来保护 WebSocket 握手消息免受 CSRF 的攻击，以避免跨站点 WebSockets 劫持漏洞；</li>
<li>将通过 WebSocket 接收的数据视为在两个方向上都不受信任，在服务器端和客户端安全地处理数据，以防止基于输入的漏洞，如 SQL 注入和 CSRF。</li>
</ol>
<p>本文参考文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32739737">WebSocket协议：5分钟从入门到精通</a>；</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39198406/article/details/106418574">使用Python创建websocket服务和客户端请求</a>；</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61044032">WebSocket 劫持漏洞</a>；</li>
<li><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/119">WebSocket应用安全问题分析</a>；</li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/328279.html">PortSwigger 基于 WebSocket 的漏洞讲解</a>。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/12/WebSocket%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BD%9C%E5%9C%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/" data-id="cl4b2cl5g0000osi9eyi68014" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/12/hello-world/" class="article-date">
  <time datetime="2022-06-12T05:26:03.301Z" itemprop="datePublished">2022-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/12/hello-world/" data-id="cl4av8krj0000noi97rmqakjk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/12/WebSocket%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BD%9C%E5%9C%A8%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/">WebSocket通信协议基础原理与潜在安全威胁</a>
          </li>
        
          <li>
            <a href="/2022/06/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Tr0e<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>